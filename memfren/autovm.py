import virtualbox
import time
from lib.config import *
from lib.errorhandel import *
from decorator import decorator
import base64

class VboxInfo():
    """Helper class, not changing machine state

    Those functions are meant to get information about the whole virtualbox
    state and not limited to a single machine like the Vbox class and need no
    running VM
    """
    def __init__(self):
        self.vb = virtualbox.VirtualBox()


    def list_vms(self):
        """Lists all VMs that are registered in VirtualBox
        """
        return "\n".join([vm.name for vm in self.vb.machines])


    def list_os_types(self):
        """Lists all os_types, that the local VirtualBox accepts
        """
        return "\n".join([os_.id_p for os_ in self.vb.guest_os_types])


@decorator
def check_running(func, *args, **kwargs):
    """decorator for use inside Vbox class only!

    ensures that the vm is running
    """
    if not args[0].running:
        print("Machine needs to be running")
        return
    return func(*args, **kwargs)


@decorator
def check_stopped(func, *args, **kwargs):
    """decorator for use inside Vbox class only!

    ensures that the vm is not running
    """
    if args[0].running:
        print("Machine needs to be stopped")
        return
    return func(*args, **kwargs)


@decorator
def check_guestsession(func, *args, **kwargs):
    """decorator for use inside Vbox class only!

    ensures that the vm has a guestsession created
    """
    if not args[0].guestsession:
        args[0].create_guest_session()

    return func(*args, **kwargs)

@decorator
def lock_if_not_running(func, *args, **kwargs):
    """decorator for use inside Vbox class only!

    locks and unlocks vm, if it is not running
    """
    if not args[0].running:
        args[0].lock()
    ret = func(*args, **kwargs)
    if not args[0].running:
        args[0].unlock()
    return ret


class Vbox():
    """base class for controlling VirtualBox

    This implements all operating system independent methods.
    Any method accepting an optional argument "wait" may return a progress
    object, to enable the user to wait, if "wait=False" is passed to it. If this
    happens, the machine might also stay in locked state!
    """

    def __init__(self, basename="ubuntu-lts-base"):
        """Initializes a VirtualBox instance

        The new instance of this class can either reuse an existing virtual
        machine or create a new one, based on a existing template. The concepts
        of sessions and machines are not exposed to the user

        Arguments:
            basename - must be in VboxInfo.list_vms()
            mode - must be VboxMode.use or VboxMode.clone
            wait - Setting wait to False enables async actions, but might break
                things, use with care!
        """

        self.vb = virtualbox.VirtualBox()

        self.vm = self.vb.find_machine(basename)

        self.os_type = self.vm.os_type_id

        self.session = self.vm.create_session()
        self.guestsession = None  # will be created by create_guest_session()
        self.os = None  # will be created by create_guest_session()
        self.basename = basename
        self.running = False
        self.speedup = 100
        self.offset = 0
        self.medium = False
        self.username = ""
        self.password = ""
        self.network = None  # Network will be stored here if needed

        self.log = ErrorHandler()
        self.log.error_log(2, "Select VM name:" + basename + " OS type: "+ self.os_type)

    def unlock(self):
        """Unlocks the machine

        This method should not be needed to be called form outside
        """
        try:
            self.session.unlock_machine()
        except:
            pass

    @check_stopped
    def start(self, session_type = SessionType.headless, wait=True):
        """start a machine

        Arguments:
            session_type - SessionType.headless means, the machine runs without
                any gui, the only sensible way on a remote server. This
                parameter is changeable to SessionType.gui for debugging only
            wait - waits till the machine is initialized, it will not have
                finished booting yet.
        """
        if not isinstance(session_type, SessionType):
            raise TypeError("session_type needs to be of type SessionType")
        self.log.error_log(0, "Start VM......")
        self.unlock()

        self.progress = self.vm.launch_vm_process(self.session,
                                                  session_type.name, [])

        self.running = True

        if wait:
            self.progress.wait_for_completion()
            while (self.session.console.guest.additions_run_level < 2):
                time.sleep(5)
        else:
            return self.progress


    @check_running
    def stop(self, stop_mode=StopMode.shutdown, confirm=StopConfirm.none,
             wait=True):
        """Stop a running machine
        Arguments:
            stop_mode - Argument of type StopMode, available options are:
                shutdown - will send acpi signal to the machine
                    might take some time for the machine to power down.
                    Can hang, if the OS requires interaction, so try to kill all
                    applications first
                poweroff - will virtually pull the power plug, works reliable
                    and fast, leaves vm in the state aborted
                save_state - freezes the virtual machine in its current state
            confirm - Argument of type StopConfirm, available options are:
                unity - workaround for Ubuntu 13.10 unity shutdown dialog
                simple - plain pressing enter, speeds up shutdown on
                    Ubuntu 12.04 unity
                xfce - confirm shutdown for xfce4
                none - no confirmation
        """
        if not isinstance(stop_mode, StopMode):
            raise TypeError("stop_mode needs to be of type StopMode")

        if not isinstance(confirm, StopConfirm):
            raise TypeError("stop_mode needs to be of type StopConfirm")

        self.log.error_log(0, "Stop the VM.....")

        if stop_mode is StopMode.poweroff:
            progress = self.session.console.power_down()
            if wait:
                progress.wait_for_completion()
                self.unlock()
                self.running = False
                self.guestsession = False
                self.os = False
            else:
                self.running = False
                self.guestsession = False
                self.os = False
                return progress

        elif stop_mode is StopMode.save_state:
            progress = self.session.console.save_state()
            if wait:
                progress.wait_for_completion()
                self.running = False
                self.guestsession = False
                self.os = False
            else:
                self.running = False
                self.guestsession = False
                self.os = False
                return progress


    def restore_snapshot(self, snap_name):
        start = time.time()
        self.log.error_log(0, "Restore snapshot...")
        try:
            snap = self.vm.find_snapshot(snap_name)
            self.vm.create_session(session=self.session)
        except virtualbox.library.VBoxError as e:
            self.log.error_log(4, "Restore snapshot failed: " + e.msg)
            return False
        except Exception as e:
            self.log.error_log(4, "Restore snapshot failed: " + str(e))
            return False

        restoring = self.session.machine.restore_snapshot(snap)

        while restoring.operation_percent < 100:
            time.sleep(0.5)

        self.unlock()
        if restoring.completed == 1:
            self.log.error_log(1, "Restore snapshot success, restoring completed in {:>.4} sec".format(str(time.time() - start)))
            return True
        else:
            self.log.error_log(4, "Restore snapshot failed, restoring not completed")
            return False

    @check_running
    def dump_memory(self, path = cur_path + "/dump/dump.elf"):
        """Creates a memory dump in 64bit elf format

        Enables analysis of non persistent data

        Arguments:
            path - path to the dump, format .elf
        """
        self.log.error_log(0, "Dump the memory......")
        self.session.console.debugger.dump_guest_core(path, "")

    @check_running
    def take_screenshot(self, path=cur_path + "/tmp/screenshot"):
        """Save screenshot to given path

        Arguments:
            path - path, where the png image should be created, format .png
        """

        h, w, _, _, _ = self.session.console.display.get_screen_resolution(0)

        png = self.session.console.display.take_screen_shot_png_to_array(0, h,
                                                                         w)
        f = open(path, 'wb')
        f.write(png)

    @check_running
    def create_guest_session(self, username="default", password="12345",
                             home="", wait=True):
        """creates a guest session for issuing commands to the guest system

        While the VirtualBox API would support up to 256 simultaneous guest
        sessions, here only one simultaneous guestsession is supported, if more
        than one guestsession are needed, they need to be manged by hand.

        Arguments:
            username - username for the vm user, the session should belong to
            password - password for the vm user, the session should belong to
        """

        self.username = username
        self.password = password

        if wait:
            while not self.guestsession:
                time.sleep(5)
                try:
                    self.guestsession = self.session.console.guest.create_session(
                        self.username, self.password)
                except:
                    pass
        else:
            self.guestsession = self.session.console.guest.create_session(
                self.username, self.password)


    @check_running
    @check_guestsession
    def copy_to_vm(self, source, dest, flags, wait=True):
        """Copy a file form outside into the VM

        This leaves no plausible trace for faking, so use with care

        Arguments:
            source - source path on the host
            dest - destination path in the vm
        """

        progress = self.guestsession.file_copy_to_guest(source, dest, flags)

        self.log.error_log(0, "Copy file from " + source + " to " + dest)

        if wait:
            progress.wait_for_completion()
        else:
            return progress

    @check_running
    @check_guestsession
    def copy_from_vm(self, source, dest, flags, wait=True):
        """Copy a file from the VM to the host

        creates no log, since it should not alter the guest

        Arguments:
            source - source path in the vm
            dest - destination path on the host
        """

        progress = self.guestsession.file_copy_from_guest(source, dest, flags)

        self.log.error_log(0, "Copy file from " + source + " to " + dest)

        if wait:
            progress.wait_for_completion()
        else:
            return progress




    @check_running
    @check_guestsession
    def run_process(self, command, arguments=[], stdin='', environment=[], native_input=False, timeout=0, wait_time=10,
                    wait=True):

        stdin = ""


        if wait:
            process, stdout, stderr = self.guestsession.execute(command=command,
                                                                arguments=arguments, stdin=stdin,
                                                                environment=environment,
                                                                timeout_ms=timeout)

        else:
            flags = [virtualbox.library.ProcessCreateFlag.wait_for_process_start_only,
                     virtualbox.library.ProcessCreateFlag.ignore_orphaned_processes]

            process = self.guestsession.process_create(executable=command,
                                                       arguments=arguments,
                                                       environment_changes=environment,
                                                       flags=flags,
                                                       timeout_ms=timeout)
        return process.pid


    def _base64_encode_command(self, command):
        """using base64 encoded commands solves issues with quoting in the
        VirtualBox execute function, needed as a workaround, for pythons
        base64 function not inserting \x00 after each char
        """

        blank_command = ""
        command = command.decode("utf-8")
        for char in command:
            blank_command += char + "\x00"

        command = blank_command.encode("utf-8")
        command = base64.b64encode(command)
        return command.decode("utf-8")

    def run_shell_cmd(self, command, cmd=False, stop_ps=False, wait=True, timeout=0):
        """runs a command inside the default shell of the user or in the legacy
        cmd.exe, needs properly split arguments for cmd=True

        Arguments:
            command - command which will be executed
            cmd - run inside a cmd or powershell
            stop_ps - kill the powershell window after running the command
        """
        power_shell = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe"
        cmd_shell = "C:\\Windows\\System32\\cmd.exe"
        if cmd:
            return self.run_process(command=cmd_shell,
                                         arguments=["/C"] + command)
        else:
            if stop_ps:
                command += b"; stop-process powershell"
            #self.log.add_encoded_command(command)
            command = self._base64_encode_command(command)
            return self.run_process(command = power_shell,
                                         arguments=["-OutputFormat", "Text",
                                                    "-inputformat", "none",
                                                    "-EncodedCommand", command], wait=wait, timeout=timeout)
